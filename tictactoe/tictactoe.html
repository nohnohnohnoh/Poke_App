<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>틱택토</title>
    <style>
      table {
        border-collapse: collapse;
      }

      td {
        border: 1px solid black;
        width: 40px;
        height: 40px;
        text-align: center;
      }
    </style>
  </head>

  <body>
    <script>
      const { body } = document;
      const $table = document.createElement("table");
      const $result = document.createElement("div");
      const rows = []; // 줄을 담당하는 배열이 있고
      let turn = "O";

      const checkWinner = (target) => {
        let rowIndex;
        let cellIndex;
        rows.forEach((row, ri) => {
          // forEach map이랑 문법 구성요서는 똑같음.
          row.forEach((cell, ci) => {
            // 차이점은 return 값이 존재하지 않는다는 것. 그러므로 새 배열을 만들필요가 없을때는 forEach를 사용.
            if ((cell = target)) {
              rowIndex = ri;
              cellIndex = ci;
            }
          });
        });
        // 세 칸 다 채워졌나
        let hasWinner = false;
        // 가로줄 검사
        if (
          rows[rowIndex][0].textContent === turn &&
          rows[rowIndex][1].textContent === turn &&
          rows[rowIndex][2].textContent === turn
        ) {
          hasWinner = true;
        }
        // 세로줄 검사
        if (
          rows[0][cellIndex].textContent === turn &&
          rows[1][cellIndex].textContent === turn &&
          rows[2][cellIndex].textContent === turn
        ) {
          hasWinner = true;
        }
        // 대각선 검사
        if (
          rows[0][0].textContent === turn &&
          rows[1][1].textContent === turn &&
          rows[2][2].textContent === turn
        ) {
          hasWinner = true;
        }
        if (
          rows[0][2].textContent === turn &&
          rows[1][1].textContent === turn &&
          rows[2][0].textContent === turn
        ) {
          hasWinner = true;
        }
        return hasWinner;
      };

      const callback = (event) => {
        // 칸이 이미 채워져 있는가?
        if (event.target.textContent !== "") return;
        // event.currentTarget 진짜 이벤트를 달아논 tag
        // event.stopPropergation() 이벤트 버블링 막는거
        if (turn === "X") {
          turn = "O";
        } else {
          turn = "X";
        }

        // 빈칸이면
        console.log("빈칸입니다");
        event.target.textContent = turn; // click을 했을 나타나는 text
      };

      for (let i = 1; i <= 3; i++) {
        const $tr = document.createElement("tr"); // 여기서 한번 행을 만들고
        const cells = [];
        for (let j = 1; j <= 3; j++) {
          // 한번 반복될때 3개의 열을 만들고
          const $td = document.createElement("td");
          // $td.addEventListener("click", callback);
          cells.push($td);
          $tr.appendChild($td); // tr안에 td를 넣고
        }
        rows.push(cells);
        $table.appendChild($tr);
        $table.addEventListener("click", callback);
      }
      body.appendChild($table);
      body.appendChild($result);
      console.log(rows);
      // table은 전체 표를 담당하는 태그 tr은 표의 가로줄을 td는 각 칸을 담당
      // 다음 객체에서 a,c,e 속성을 구조분해 할당 문법으로 변수에 할당 // const obj =
      //{ // a: "hello", // b: { // c: "hi", // d: { e: "wow" }, // }, // }; //
      //const { // a, // b: { // c, // d: { e }, // }, // } = obj;
    </script>
  </body>
</html>
